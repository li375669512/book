<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>TCP Socket</title>
<title>Network Component: TCP Socket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="drv.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylsheetf" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo"><img alt="Logo" src="keilarm.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Network Component
   &#160;<span id="projectnumber">Version 6.7.7</span>
   </div>
   <div id="projectbrief">MDK-Professional Middleware for IP Networking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="DRVnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Usage&#160;and&#160;Description</span></a></li>
      <li><a href="modules.html"><span>Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('using_network_sockets_tcp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TCP Socket </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section describes the implementation of the <b>Transmission Control Protocol (TCP)</b> in the Network Component. TCP runs on top of the Internet Protocol (IP). TCP is a <b>connection-oriented</b> and <b>reliable full duplex protocol</b> supporting a pair of byte streams, one for each direction. A TCP connection must be <b>established</b> before exchanging data. TCP <b>retransmits</b> data that do not reach the final destination due to errors or data corruption. Data is delivered in the sequence of its transmission.</p>
<h1><a class="anchor" id="opening_tcp"></a>
Opening a TCP Connection</h1>
<p>Before a client can connect to a server, the server must first bind to and listen at a port to open it up for connections. This is called a <b>passive open</b>. Once the passive open is established, a client may initiate an <b>active open</b>. In fact, a passive open can specify that the server is waiting for an active open from a specific client.</p>
<p>In the <b>Net_Config_TCP.h</b> configuration file the usage of TCP sockets is automatically enabled. In addition, to open an active or passive TCP connection, you need to call the <a class="el" href="group__net__system__functions.html#gaafbf279f22e31e4822d9025b9e986d22" title="Run Network Component main function. ">net_main()</a> function. This function handles all protocol related data. It has to be run frequently to ensure proper operation. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main (<span class="keywordtype">void</span>) {</div>
<div class="line">  init ();</div>
<div class="line">  <span class="comment">// Initialize the Network Core</span></div>
<div class="line">  <a class="code" href="group__net__system__functions.html#gac115122a03cf6b4b8874045f88e6ac5f">net_initialize</a> ();</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">  <span class="comment">// Run main Network Core &#39;thread&#39;</span></div>
<div class="line">    <a class="code" href="group__net__system__functions.html#gaafbf279f22e31e4822d9025b9e986d22">net_main</a> ();</div>
<div class="line">  ..</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The Network Component can handle multiple connections on the same port. Several applications (for example Web server, FTP server, Telnet server, etc.) are using this concept.</p>
<h1><a class="anchor" id="sending_data"></a>
Sending TCP Data</h1>
<p>The TCP protocol is a byte stream service. It does not know anything about the format of the data being sent. It simply takes the data, <b>encapsulates</b> it into a TCP packet, and sends it to the remote peer. The TCP socket then keeps sent packets in memory and waits for an <b>acknowledge</b> from the remote peer.</p>
<p>If the packet is not acknowledged when the timeout expires, the same packet is <b>resent</b>. This process is repeated until a packet is either acknowledged or the TCP socket <b>aborts</b> the connection.</p>
<p>To be able to successfully send data via TCP, you first need to request a buffer to be allocated using <a class="el" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a>. Then, fill the buffer with the data to be sent and send it using <a class="el" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a>. The buffer will be released by the Network Component automatically. If the buffer is not valid (not allocated with the <a class="el" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> function), the buffer is ignored.</p>
<p>The Network Component does not send 0-length packets. So it is possible to release a buffer that has been allocated, by simply calling <a class="el" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> with parameter <em>len</em> = 0.</p>
<h1><a class="anchor" id="example_sending_data"></a>
Example for Sending Data</h1>
<p>The following example shows how to send large amounts of data using TCP sockets. 64 Kbytes are sent to the remote IP address 192.168.0.100, which is listening on port 1000. The TCP socket is permanently allocated and is not released when the data is sent or when the connection is closed.</p>
<ol type="1">
<li>Initialize the Network Component (using <a class="el" href="group__net__system__functions.html#gac115122a03cf6b4b8874045f88e6ac5f">net_initialize</a>) and allocate a free TCP socket (using <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>): <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">uint8_t tcp_soc;</div>
<div class="line">uint8_t soc_state;</div>
<div class="line"><span class="keywordtype">bool</span> wait_ack;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main (<span class="keywordtype">void</span>) {</div>
<div class="line">  <a class="code" href="group__net__system__functions.html#gac115122a03cf6b4b8874045f88e6ac5f">net_initialize</a>();</div>
<div class="line">  tcp_soc = <a class="code" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> (<a class="code" href="rl__net_8h.html#a203a453411d5b2fedc192c787b390c04">TCP_TYPE_CLIENT</a>, 0, 120, tcp_callback);</div>
<div class="line">  soc_state = 0;</div>
</div><!-- fragment --> <br/>
</li>
<li>Run <a class="el" href="group__net__system__functions.html#gaafbf279f22e31e4822d9025b9e986d22">net_main</a> of the Network Component and call the <b>send_data()</b> function from an endless loop: <div class="fragment"><div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <a class="code" href="group__net__system__functions.html#gaafbf279f22e31e4822d9025b9e986d22">net_main</a> ();</div>
<div class="line">    send_data ();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> <br/>
</li>
<li>The <b>send_data()</b> function must be implemented as a state machine. It opens an active TCP connection, sends data, and closes the TCP connection in the end. When the <code>soc_state</code> is 0, the connection is initiated (using <a class="el" href="group__tcp__routines.html#ga2b350880a0604c26cefcf01c5fdfe980">tcp_connect</a>): <div class="fragment"><div class="line"><span class="keywordtype">void</span> send_data (<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> uint8_t rem_IP[4] = {192,168,0,100};</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> bcount;</div>
<div class="line">  uint32_t max;</div>
<div class="line">  uint8_t *sendbuf;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">switch</span> (soc_state) {</div>
<div class="line">    <span class="keywordflow">case</span> 0:</div>
<div class="line">      <a class="code" href="group__tcp__routines.html#ga2b350880a0604c26cefcf01c5fdfe980">tcp_connect</a> (tcp_soc, rem_IP, 1000, 0);</div>
<div class="line">      bcount    = 0;</div>
<div class="line">      wait_ack  = <span class="keyword">false</span>;</div>
<div class="line">      soc_state = 1;</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
</div><!-- fragment --> <br/>
</li>
<li>Next, state 1 is waiting for the <span class="XML-Token">tcpEventConnect</span> event. This event is received in the <b>tcp_callback()</b> event callback function, which places the <b>send_data()</b> process into state 2 (sending data state). <br/>
</li>
<li>In state 2, allocate the maximum possible size of transmit buffer (using <a class="el" href="group__tcp__routines.html#gaabe67549230e521404e9705e37056c89">tcp_max_data_size</a>), fill it with some data, and send it. The maximum possible transmit buffer is allocated to reduce the number of packets and improve the transfer speed. <br/>
 After the packet is sent, wait for the <b>remote acknowledge</b> before proceeding with the next data packet. <div class="fragment"><div class="line"><span class="keywordflow">case</span> 2:</div>
<div class="line">  <span class="keywordflow">if</span> (wait_ack == <span class="keyword">true</span>) {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  max = tcp_max_dsize (tcp_soc);</div>
<div class="line">  sendbuf = <a class="code" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> (max);</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; max; i += 2) {</div>
<div class="line">    sendbuf[i]   = bcount &gt;&gt; 8;</div>
<div class="line">    sendbuf[i+1] = bcount &amp; 0xFF;</div>
<div class="line">    <span class="keywordflow">if</span> (bcount &gt;= 32768) {</div>
<div class="line">      soc_state = 3;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <a class="code" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> (tcp_soc, sendbuf, i);</div>
<div class="line">  wait_ack = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
</div><!-- fragment --> <br/>
</li>
<li>State 3 is achieved when the data transfer is finished. Wait for the last packet to be acknowledged and then close the TCP connection (using <a class="el" href="group__tcp__routines.html#ga4d298c3a3ba5d9b25089e9bc026e663a">tcp_close</a>). <div class="fragment"><div class="line">    <span class="keywordflow">case</span> 3:</div>
<div class="line">      <span class="keywordflow">if</span> (wait_ack == <span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      <a class="code" href="group__tcp__routines.html#ga4d298c3a3ba5d9b25089e9bc026e663a">tcp_close</a> (tcp_soc);</div>
<div class="line">      soc_state = 4;</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> <br/>
</li>
<li>The embedded application waits for the TCP socket to <b>connect</b> before starting to send data. When the data packet is sent, the application waits for the <b>acknowledge</b> before creating and sending the next data packet. Use the callback <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">listener</a> function to wait for the remote acknowledge. <div class="fragment"><div class="line">uint32_t tcp_callback (int32_t <a class="code" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>, <a class="code" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> event, <span class="keyword">const</span> uint8_t *buf, uint32_t len)  {</div>
<div class="line">  <span class="comment">// This function is called on TCP event</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">switch</span> (event) {</div>
<div class="line">     ..</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a7f6c1d6db00e171f1fcaeee7e6231875">tcpEventConnect</a>:</div>
<div class="line">      <span class="comment">// Socket is now connected and ready to send data.</span></div>
<div class="line">      soc_state = 2;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7ac41a0c7a4531098a946ca62ab6ef1951">tcpEventACK</a>:</div>
<div class="line">      <span class="comment">// Our sent data has been acknowledged by remote peer</span></div>
<div class="line">      wait_ack = <span class="keyword">false</span>;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">       ..</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (0);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This assumes that the Network Interface Adapter is selected, enabled, and properly configured.</li>
<li>If the system runs out of TCP sockets, the application hangs in an endless loop. The system error function will respond with the error code <b>ERR_TCP_ALLOC</b>.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="multiple_tcp_connections"></a>
Multiple TCP Connections</h1>
<p>Server applications often require to be able to accept several TCP connections from clients on the <b>same port</b>. The handling of these multiple connections must be implemented in the <b>user application</b>.</p>
<p>Because TCP socket is a connection-oriented service, it accepts only one concurrent connection. The basic packet multiplexing is done in the TCP Transport layer and the user application receives the <b>socket number</b> as a parameter in the callback function.</p>
<p>The framework of the user application shall contain the following basic functions:</p>
<ol type="1">
<li>The <b>user_init()</b> function to initialize all user application sessions at startup. <div class="fragment"><div class="line"><span class="keywordtype">void</span> user_init () {</div>
<div class="line">  USER_INFO *user_s;</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; user_num_sess; i++) {</div>
<div class="line">    user_s = &amp;user_session[i];</div>
<div class="line">    user_s-&gt;Count = 0;</div>
<div class="line">    user_s-&gt;Flags = 0;</div>
<div class="line">    user_s-&gt;BCnt  = 0;</div>
<div class="line">    user_s-&gt;Tout  = 0;</div>
<div class="line">    user_s-&gt;File  = NULL;</div>
<div class="line">    user_s-&gt;Script= NULL;</div>
<div class="line">    <span class="comment">// Allocate a TCP socket for the session.</span></div>
<div class="line">    user_s-&gt;Socket = <a class="code" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> (<a class="code" href="rl__net_8h.html#a0d8130d6f21b0992437f49d907f51011">TCP_TYPE_SERVER</a>, TCP_TOS_NORMAL,</div>
<div class="line">                     120, user_listener);</div>
<div class="line">    user_s-&gt;State = USER_STATE_ERROR;</div>
<div class="line">    <span class="keywordflow">if</span> (user_s-&gt;Socket &gt; 0) {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="group__tcp__routines.html#ga0becf4747e9fdb8d449a4d478e1a982a">tcp_listen</a> (user_s-&gt;Socket, USER_SERVER_PORT) == <a class="code" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551a138e73e2c0ad9ef9426ac81ef809953b">netOK</a>) {</div>
<div class="line">        user_s-&gt;State = USER_STATE_IDLE;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> All user sessions are now initialized and each session has allocated it's own TCP socket. A socket is listening on selected <b>USER_SERVER_PORT</b> port.</li>
<li>The <b>user_listener()</b> callback function for TCP socket. This callback function is common for all TCP sockets allocated in this user application. <div class="fragment"><div class="line">uint32_t user_listener (int32_t socket, <a class="code" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> event, <span class="keyword">const</span> uint8_t *buf, uint32_t len)  {</div>
<div class="line">  USER_INFO *user_s;</div>
<div class="line">  uint8_t session;</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"></div>
<div class="line">  session = user_map_session (socket);</div>
<div class="line">  <span class="keywordflow">if</span> (session == 0)) {</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line">  user_s = &amp;user_session[session-1];</div>
<div class="line">  <span class="keywordflow">switch</span> (event) {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a6659fcc0776e254d99ce76d7ec670704">tcpEventEstablished</a>:</div>
<div class="line">      <span class="keywordflow">if</span> (user_s-&gt;State == USER_STATE_IDLE) {</div>
<div class="line">        user_s-&gt;State = USER_STATE_RESERVED;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a448881089a3a56cf064676fe96bb134e">tcpEventAbort</a>:</div>
<div class="line">      user_kill_session (user_s);</div>
<div class="line">      <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a7f6c1d6db00e171f1fcaeee7e6231875">tcpEventConnect</a>:</div>
<div class="line">      user_s-&gt;State = USER_STATE_ACTIVE;</div>
<div class="line">      <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7af3bc3ec2888d904f73df0cfd86818b56">tcpEventClosed</a>:</div>
<div class="line">      user_kill_session (user_s);</div>
<div class="line">      <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7ac41a0c7a4531098a946ca62ab6ef1951">tcpEventACK</a>:</div>
<div class="line">      user_s-&gt;Count += user_s-&gt;BCnt;</div>
<div class="line">      user_s-&gt;BCnt = 0;</div>
<div class="line">      <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a810f89319c9fa0cbfea81f999f948571">tcpEventData</a>:</div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>The <b>user_map_session()</b> function to map the socket, which has generated a callback event, to it's owner session. <div class="fragment"><div class="line"><span class="keyword">static</span> uint8_t user_map_session (uint8_t socket) {</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (i = 1; i &lt;= user_num_sess; i++) {</div>
<div class="line">    <span class="keywordflow">if</span> (user_session[i-1].Socket == socket) {</div>
<div class="line">      <span class="keywordflow">return</span> (i);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (0);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>The <b>user_kill_session()</b> function to initialize the session to a default state, close any eventually opened files and release any eventually allocated buffers. <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> user_kill_session (USER_INFO *user_s) {</div>
<div class="line"></div>
<div class="line">  user_s-&gt;State =  USER_STATE_IDLE;</div>
<div class="line">  <span class="keywordflow">if</span> (user_s-&gt;Flags &amp; USER_FLAG_FOPENED) {</div>
<div class="line">    user_fclose (user_s-&gt;File);</div>
<div class="line">    user_s-&gt;File = NULL;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (user_s-&gt;Script != NULL) {</div>
<div class="line">    free_mem (user_s-&gt;Script);</div>
<div class="line">    user_s-&gt;Script = NULL;</div>
<div class="line">  }</div>
<div class="line">  user_s-&gt;Flags = 0;</div>
<div class="line">  user_s-&gt;Count = 0;</div>
<div class="line">  user_s-&gt;BCnt  = 0;</div>
<div class="line">  user_s-&gt;Tout  = 0;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>The <b>user_run_server()</b> function to maintain the application jobs, timeouts, etc. This function shall be frequently called from the main loop. <div class="fragment"><div class="line"><span class="keywordtype">void</span> user_run_server () {</div>
<div class="line">  USER_INFO *user_s;</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; user_num_sess; i++) {</div>
<div class="line">    user_s = &amp;user_session[i];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">switch</span> (user_s-&gt;State) {</div>
<div class="line">      <span class="keywordflow">case</span> USER_STATE_IDLE:</div>
<div class="line">      <span class="keywordflow">case</span> USER_STATE_RESERVED:</div>
<div class="line">        <span class="comment">// Keep TCP sockets listening.</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__tcp__routines.html#ga633f175ef72aaac9c513454f4b245ee7">tcp_get_state</a> (user_s-&gt;Socket) &lt; <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0baff60ac1a5d126e459570af908e62c79f">tcpStateLISTEN</a>) {</div>
<div class="line">          <a class="code" href="group__tcp__routines.html#ga0becf4747e9fdb8d449a4d478e1a982a">tcp_listen</a> (user_s-&gt;Socket, USER_SERVER_PORT);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> USER_STATE_WAITING:</div>
<div class="line">        <span class="keywordflow">if</span> (sec_tick == <span class="keyword">true</span>) {</div>
<div class="line">          <span class="keywordflow">if</span> (--user_s-&gt;Tout == 0) {</div>
<div class="line">            <span class="comment">// A timeout expired.</span></div>
<div class="line">            user_kill_session (user_s);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> USER_STATE_ACTIVE:</div>
<div class="line">         ..</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<dl class="section note"><dt>Note</dt><dd>One TCP socket will be used for every user session. You need to reserve enough TCP sockets in the <b>Net_Config_TCP.h</b> configuration file for all user sessions.</dd></dl>
<h1><a class="anchor" id="using_network_sockets_tcp_conf"></a>
TCP Socket Configuration</h1>
<div class="image">
<img src="net_config_tcp_h.png" alt="net_config_tcp_h.png"/>
<div class="caption">
TCP Socket Configuration File</div></div>
<p> The TCP sockets configuration file <b>Net_Config_TCP.h</b> contains the following settings:</p>
<ul>
<li><b>Number of TCP Sockets</b> specifies the number of available TCP sockets. This number specifies the maximum number of simultaneously opened TCP connections.</li>
<li><b>Number of Retries</b> specifies the number of retransmissions before the TCP module gives up. Data is retransmitted if it is not acknowledged within the timeout frame defined by the <b>Retry Timeout in seconds</b>.</li>
<li><b>Retry Timeout in seconds</b> is the timeout after which the TCP module retransmits the data. This is the initial timeout value. When the data exchange is going on, the system measures the response time and corrects this timeout.</li>
<li><b>Default Connect Timeout in seconds</b> is the default <a href="http://en.wikipedia.org/wiki/Keep-alive_connection" class="el" target="_blank">keep-alive</a> timeout. After this timeout has expired, the TCP link is disconnected. This parameter is used for services such as <a class="el" href="using_http_server.html">HTTP Web Server</a> and <a class="el" href="using_telnet_server.html">Telnet Server</a>.</li>
<li><b>Maximum Segment Size</b> specifies the maximum number of bytes in the TCP segment's data field. Acceptable values for this parameter are in the range from 536 to 1460 bytes.</li>
<li><b>Receive Window Size</b> specifies the amount of data the TCP socket is able to buffer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="using_network_components.html">Using Network Components</a></li><li class="navelem"><a class="el" href="using_network_sockets.html">Sockets</a></li>
    <li class="footer">Generated on Tue May 25 2021 13:57:56 for Network Component by ARM Ltd. All rights reserved.
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 
	-->
	</li>
  </ul>
</div>
</body>
</html>
