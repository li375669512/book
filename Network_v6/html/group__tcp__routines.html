<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>TCP Socket</title>
<title>Network Component: TCP Socket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="drv.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylsheetf" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo"><img alt="Logo" src="keilarm.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Network Component
   &#160;<span id="projectnumber">Version 6.7.7</span>
   </div>
   <div id="projectbrief">MDK-Professional Middleware for IP Networking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="DRVnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Usage&#160;and&#160;Description</span></a></li>
      <li><a href="modules.html"><span>Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__tcp__routines.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TCP Socket<div class="ingroups"><a class="el" href="group__net__sockets.html">Sockets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>TCP socket routines enable reliable IP communication using the transmission control protocol (TCP).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="memitem:ga02be6af8d62202579630484e0c8297c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> { <br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7a7f6c1d6db00e171f1fcaeee7e6231875">tcpEventConnect</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7a6659fcc0776e254d99ce76d7ec670704">tcpEventEstablished</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7af3bc3ec2888d904f73df0cfd86818b56">tcpEventClosed</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7a448881089a3a56cf064676fe96bb134e">tcpEventAbort</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7ac41a0c7a4531098a946ca62ab6ef1951">tcpEventACK</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7a810f89319c9fa0cbfea81f999f948571">tcpEventData</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga02be6af8d62202579630484e0c8297c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP Callback Events.  <a href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">More...</a><br/></td></tr>
<tr class="separator:ga02be6af8d62202579630484e0c8297c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc39a1c61c0ec06bb63d8e120cd84b0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0b">tcpState</a> { <br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0ba80eea572593e77abb663121f399f755c">tcpStateUNUSED</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0baac035e480de8c9b4932aadcf701f18f7">tcpStateCLOSED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0baff60ac1a5d126e459570af908e62c79f">tcpStateLISTEN</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0bad1b2b94f3a8581d07bca68897b1e7197">tcpStateSYN_RECEIVED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0bafcc725aa6744d525ed1210227212306b">tcpStateSYN_SENT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0bac70a033b1b15bdde54bed7272ba99509">tcpStateFIN_WAIT_1</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0badb906389aac94eeee50711bc301b5006">tcpStateFIN_WAIT_2</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0baf8b464c1c5e110c0c2928ed197030ccf">tcpStateCLOSING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0ba200093f14064e6c762803e2b0f94087b">tcpStateLAST_ACK</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0bab47802b6649ee34479f0e232a1977034">tcpStateTIME_WAIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0ba646b8c1597e3b2328c8bf218a624c19a">tcpStateESTABLISHED</a>
<br/>
 }</td></tr>
<tr class="memdesc:gadc39a1c61c0ec06bb63d8e120cd84b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP States.  <a href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0b">More...</a><br/></td></tr>
<tr class="separator:gadc39a1c61c0ec06bb63d8e120cd84b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace2a5afa1443e45e16fa795be3afb322"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#gace2a5afa1443e45e16fa795be3afb322">net_tcp_cb_t</a> )(int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>, <a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> event, const uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:gace2a5afa1443e45e16fa795be3afb322"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP Event callback function.  <a href="#gace2a5afa1443e45e16fa795be3afb322">More...</a><br/></td></tr>
<tr class="separator:gace2a5afa1443e45e16fa795be3afb322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b571ec995be3255b7d5fa5f24634ad"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> (uint8_t type, uint8_t tos, uint32_t tout, <a class="el" href="group__tcp__routines.html#gace2a5afa1443e45e16fa795be3afb322">net_tcp_cb_t</a> cb_func)</td></tr>
<tr class="memdesc:ga43b571ec995be3255b7d5fa5f24634ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a free TCP socket.  <a href="#ga43b571ec995be3255b7d5fa5f24634ad">More...</a><br/></td></tr>
<tr class="separator:ga43b571ec995be3255b7d5fa5f24634ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd7657e8663ae78c0ad14084531a282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#gacfd7657e8663ae78c0ad14084531a282">tcp_release_socket</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>)</td></tr>
<tr class="memdesc:gacfd7657e8663ae78c0ad14084531a282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release TCP socket and free resources.  <a href="#gacfd7657e8663ae78c0ad14084531a282">More...</a><br/></td></tr>
<tr class="separator:gacfd7657e8663ae78c0ad14084531a282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0becf4747e9fdb8d449a4d478e1a982a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga0becf4747e9fdb8d449a4d478e1a982a">tcp_listen</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>, uint16_t port)</td></tr>
<tr class="memdesc:ga0becf4747e9fdb8d449a4d478e1a982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open TCP socket for incoming connection.  <a href="#ga0becf4747e9fdb8d449a4d478e1a982a">More...</a><br/></td></tr>
<tr class="separator:ga0becf4747e9fdb8d449a4d478e1a982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b350880a0604c26cefcf01c5fdfe980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga2b350880a0604c26cefcf01c5fdfe980">tcp_connect</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>, const uint8_t *ip_addr, uint16_t port, uint16_t local_port)</td></tr>
<tr class="memdesc:ga2b350880a0604c26cefcf01c5fdfe980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a TCP connection to a remote node.  <a href="#ga2b350880a0604c26cefcf01c5fdfe980">More...</a><br/></td></tr>
<tr class="separator:ga2b350880a0604c26cefcf01c5fdfe980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0cf899981f5ceade155b43ee4de5b6"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> (uint32_t size)</td></tr>
<tr class="memdesc:ga2d0cf899981f5ceade155b43ee4de5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for TCP send buffer.  <a href="#ga2d0cf899981f5ceade155b43ee4de5b6">More...</a><br/></td></tr>
<tr class="separator:ga2d0cf899981f5ceade155b43ee4de5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe67549230e521404e9705e37056c89"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#gaabe67549230e521404e9705e37056c89">tcp_max_data_size</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>)</td></tr>
<tr class="memdesc:gaabe67549230e521404e9705e37056c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine maximum number of data bytes that can be sent in TCP packet.  <a href="#gaabe67549230e521404e9705e37056c89">More...</a><br/></td></tr>
<tr class="separator:gaabe67549230e521404e9705e37056c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28c4ed241d2df8ad14b0f12f4b3eac37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga28c4ed241d2df8ad14b0f12f4b3eac37">tcp_check_send</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>)</td></tr>
<tr class="memdesc:ga28c4ed241d2df8ad14b0f12f4b3eac37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TCP socket can send data.  <a href="#ga28c4ed241d2df8ad14b0f12f4b3eac37">More...</a><br/></td></tr>
<tr class="separator:ga28c4ed241d2df8ad14b0f12f4b3eac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633f175ef72aaac9c513454f4b245ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0b">tcpState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga633f175ef72aaac9c513454f4b245ee7">tcp_get_state</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>)</td></tr>
<tr class="memdesc:ga633f175ef72aaac9c513454f4b245ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine current state of a TCP socket.  <a href="#ga633f175ef72aaac9c513454f4b245ee7">More...</a><br/></td></tr>
<tr class="separator:ga633f175ef72aaac9c513454f4b245ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04258a1f5a0fb1d847bf00194ecc8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>, uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:gae04258a1f5a0fb1d847bf00194ecc8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a data packet to remote node.  <a href="#gae04258a1f5a0fb1d847bf00194ecc8f5">More...</a><br/></td></tr>
<tr class="separator:gae04258a1f5a0fb1d847bf00194ecc8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d298c3a3ba5d9b25089e9bc026e663a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga4d298c3a3ba5d9b25089e9bc026e663a">tcp_close</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>)</td></tr>
<tr class="memdesc:ga4d298c3a3ba5d9b25089e9bc026e663a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop TCP communication and start closing procedure.  <a href="#ga4d298c3a3ba5d9b25089e9bc026e663a">More...</a><br/></td></tr>
<tr class="separator:ga4d298c3a3ba5d9b25089e9bc026e663a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b40899a11b2196853e49a7b4f442078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#ga7b40899a11b2196853e49a7b4f442078">tcp_abort</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>)</td></tr>
<tr class="memdesc:ga7b40899a11b2196853e49a7b4f442078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantly stop TCP communication.  <a href="#ga7b40899a11b2196853e49a7b4f442078">More...</a><br/></td></tr>
<tr class="separator:ga7b40899a11b2196853e49a7b4f442078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad79b3dfdadecaa7b11db7a12fdc51643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__routines.html#gad79b3dfdadecaa7b11db7a12fdc51643">tcp_reset_window</a> (int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>)</td></tr>
<tr class="memdesc:gad79b3dfdadecaa7b11db7a12fdc51643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset TCP window size to a default value from the configuration.  <a href="#gad79b3dfdadecaa7b11db7a12fdc51643">More...</a><br/></td></tr>
<tr class="separator:gad79b3dfdadecaa7b11db7a12fdc51643"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>TCP socket routines enable reliable IP communication using the transmission control protocol (TCP). </p>
<p>The Transmission Control Protocol (TCP) runs on top of the Internet Protocol (IP). TCP is a connection-oriented and reliable full duplex protocol supporting a pair of byte streams, one for each direction. The two applications must establish a TCP connection before exchanging data. TCP retransmits data that do not reach the final destination due to errors or data corruption. Data are delivered in the sequence of their transmission.</p>
<dl class="section note"><dt>Note</dt><dd>More information on the usage of TCP and how to work with the functions is available at <a class="el" href="using_network_sockets_tcp.html">TCP Socket</a>. </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gace2a5afa1443e45e16fa795be3afb322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* net_tcp_cb_t)(int32_t <a class="el" href="group__bsd__routines.html#gabd21dff339393ec8e83b439d1120df71">socket</a>, <a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> event, const uint8_t *buf, uint32_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP Event callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>TCP socket handle of the local machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event type as shown in the table below (<a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to a buffer containing the received data or to the IP address of the remote machine (see below). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of data bytes or port number of the remote machine (see below). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer Value used to decide whether to accept or reject an incoming connection (see details).<ul>
<li><b>1</b> - incomming connection accepted.</li>
<li><b>0</b> - incomming connection rejected.</li>
</ul>
</dd></dl>
<p>Is the type definition for the TCP callback function.</p>
<p>The event callback function of the TCP socket is called by the Network Core whenever a TCP event occurs.</p>
<p>The argument <em>socket</em> is the TCP socket handle of the local machine. The argument <em>event</em> specifies the type of event that occurred as shown in the table below or <a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a>. The argument <em>buf</em> points to a buffer or to an IP address. If event is <span class="XML-Token">tcpEventData</span>, then <em>buf</em> points to a buffer containing the received data. For all other events, <em>buf</em> points to the IP address of the remote machine. The argument <em>len</em> specifies the data length or port number of the remote machine. If event is <span class="XML-Token">tcpEventData</span>, then <em>len</em> specifies the number of received data bytes. For all other events, <em>len</em> specifies the <b>port</b> number used by the remote machine.</p>
<p>The Network Core uses the return value of the callback function only when the event is <span class="XML-Token">tcpEventConnect</span>. It uses the return value to decide whether to accept or reject an incoming connection when the TCP socket is listening. If the listener function returns <span class="XML-Token">1</span>, then it accepts the incoming connection. If the listener function returns <span class="XML-Token">0</span>, it rejects the incoming connection. Thus, you can define the listener function to selectively reject incoming connections from particular IP addresses.</p>
<table class="doxtable">
<tr>
<th>Event Type </th><th>Description  </th></tr>
<tr>
<td><span class="XML-Token">tcpEventConnect</span> </td><td>A Connect Request has been received from a remote client that wants to connect to the server </td></tr>
<tr>
<td><span class="XML-Token">tcpEventEstablished</span></td><td>The TCP socket has connected to the remote machine </td></tr>
<tr>
<td><span class="XML-Token">tcpEventClosed</span> </td><td>The TCP connection has been properly closed </td></tr>
<tr>
<td><span class="XML-Token">tcpEventAbort</span> </td><td>The TCP connection has been aborted </td></tr>
<tr>
<td><span class="XML-Token">tcpEventACK</span> </td><td>Acknowledgement has been received from the remote host for the previously sent data </td></tr>
<tr>
<td><span class="XML-Token">tcpEventData</span> </td><td>A TCP data packet has been received </td></tr>
</table>
<p><b>Parameter for:</b></p>
<ul>
<li><a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga02be6af8d62202579630484e0c8297c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP Callback Events. </p>
<p><b>Parameter for:</b></p>
<ul>
<li><a class="el" href="group__tcp__routines.html#gace2a5afa1443e45e16fa795be3afb322">net_tcp_cb_t</a> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ga02be6af8d62202579630484e0c8297c7a7f6c1d6db00e171f1fcaeee7e6231875"></a>tcpEventConnect</em>&#160;</td><td class="fielddoc">
<p>Connect request received event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga02be6af8d62202579630484e0c8297c7a6659fcc0776e254d99ce76d7ec670704"></a>tcpEventEstablished</em>&#160;</td><td class="fielddoc">
<p>Connection established event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga02be6af8d62202579630484e0c8297c7af3bc3ec2888d904f73df0cfd86818b56"></a>tcpEventClosed</em>&#160;</td><td class="fielddoc">
<p>Connection was properly closed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga02be6af8d62202579630484e0c8297c7a448881089a3a56cf064676fe96bb134e"></a>tcpEventAbort</em>&#160;</td><td class="fielddoc">
<p>Connection is for some reason aborted. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga02be6af8d62202579630484e0c8297c7ac41a0c7a4531098a946ca62ab6ef1951"></a>tcpEventACK</em>&#160;</td><td class="fielddoc">
<p>Previously send data acknowledged. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga02be6af8d62202579630484e0c8297c7a810f89319c9fa0cbfea81f999f948571"></a>tcpEventData</em>&#160;</td><td class="fielddoc">
<p>Data received event. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0b">tcpState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP States. </p>
<p><b>Returned by:</b></p>
<ul>
<li><a class="el" href="group__tcp__routines.html#ga633f175ef72aaac9c513454f4b245ee7">tcp_get_state</a> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0ba80eea572593e77abb663121f399f755c"></a>tcpStateUNUSED</em>&#160;</td><td class="fielddoc">
<p>Entry is free and unused. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0baac035e480de8c9b4932aadcf701f18f7"></a>tcpStateCLOSED</em>&#160;</td><td class="fielddoc">
<p>Entry allocated, socket still closed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0baff60ac1a5d126e459570af908e62c79f"></a>tcpStateLISTEN</em>&#160;</td><td class="fielddoc">
<p>Socket waiting for incoming connection. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0bad1b2b94f3a8581d07bca68897b1e7197"></a>tcpStateSYN_RECEIVED</em>&#160;</td><td class="fielddoc">
<p>SYN frame received. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0bafcc725aa6744d525ed1210227212306b"></a>tcpStateSYN_SENT</em>&#160;</td><td class="fielddoc">
<p>SYN packet sent to establish a connection. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0bac70a033b1b15bdde54bed7272ba99509"></a>tcpStateFIN_WAIT_1</em>&#160;</td><td class="fielddoc">
<p>Tcp_close started FIN packet was sent. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0badb906389aac94eeee50711bc301b5006"></a>tcpStateFIN_WAIT_2</em>&#160;</td><td class="fielddoc">
<p>Our FIN ack-ed, waiting for remote FIN. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0baf8b464c1c5e110c0c2928ed197030ccf"></a>tcpStateCLOSING</em>&#160;</td><td class="fielddoc">
<p>Received FIN independently of our FIN. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0ba200093f14064e6c762803e2b0f94087b"></a>tcpStateLAST_ACK</em>&#160;</td><td class="fielddoc">
<p>Waiting for last ACK for our FIN. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0bab47802b6649ee34479f0e232a1977034"></a>tcpStateTIME_WAIT</em>&#160;</td><td class="fielddoc">
<p>Timed waiting for 2MSL. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gadc39a1c61c0ec06bb63d8e120cd84b0ba646b8c1597e3b2328c8bf218a624c19a"></a>tcpStateESTABLISHED</em>&#160;</td><td class="fielddoc">
<p>TCP Connection established. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7b40899a11b2196853e49a7b4f442078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a> tcp_abort </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantly stop TCP communication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code that indicates the execution status of the function as defined with <a class="el" href="rl__net_8h.html#a5675a3b88ee02986ae15ae3bb8135551">netStatus</a>.</dd></dl>
<p>The function <b>tcp_abort</b> closes the TCP connection immediately by sending a TCP frame with the RESET flag set to the remote machine.</p>
<p>The argument <em>socket</em> specifies the handle of the socket.</p>
<p>The Network Core calls the listener callback function only when a remote peer has aborted the connection. If the aborted socket is initiated locally by calling <b>tcp_abort</b>, then the callback function is not called.</p>
<dl class="section note"><dt>Note</dt><dd>After calling <b>tcp_abort</b> you cannot use the socket to send or receive any data. The socket remains allocated until you release it.</dd></dl>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> disconnect_tcp (int32_t tcp_soc) {</div>
<div class="line">   ..</div>
<div class="line">  <span class="comment">// This TCP connection needs to close immediately</span></div>
<div class="line">  <a class="code" href="group__tcp__routines.html#ga7b40899a11b2196853e49a7b4f442078">tcp_abort</a> (tcp_soc);</div>
<div class="line">  <span class="comment">// Socket will not be needed any more </span></div>
<div class="line">  <a class="code" href="group__tcp__routines.html#gacfd7657e8663ae78c0ad14084531a282">tcp_release_socket</a> (tcp_soc);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga28c4ed241d2df8ad14b0f12f4b3eac37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tcp_check_send </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if TCP socket can send data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>send status:<ul>
<li>true = Ready to send data.</li>
<li>false = Not ready.</li>
</ul>
</dd></dl>
<p>The function <b>tcp_check_send</b> determines whether the TCP socket can send data. It does this by checking whether the TCP connection has been established and whether the socket has received an acknowledgement from the remote machine for data sent previously.</p>
<p>The argument <em>socket</em> specifies the socket handle.</p>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> send_data () {</div>
<div class="line">  <span class="keyword">const</span> uint8_t rem_ip[4] = {192,168,1,100};</div>
<div class="line">  uint8_t *sendbuf;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">switch</span> (<a class="code" href="group__tcp__routines.html#ga633f175ef72aaac9c513454f4b245ee7">tcp_get_state</a> (socket_tcp)) {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0ba80eea572593e77abb663121f399f755c">tcpStateUNUSED</a>:</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0baac035e480de8c9b4932aadcf701f18f7">tcpStateCLOSED</a>:</div>
<div class="line">      <span class="comment">// Connection idle, send Connect Request. </span></div>
<div class="line">      <a class="code" href="group__tcp__routines.html#ga2b350880a0604c26cefcf01c5fdfe980">tcp_connect</a> (socket_tcp, rem_ip, 1001, 0);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0ba646b8c1597e3b2328c8bf218a624c19a">tcpStateESTABLISHED</a>:</div>
<div class="line">      <span class="comment">// We are connected, send command to remote peer. </span></div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="group__tcp__routines.html#ga28c4ed241d2df8ad14b0f12f4b3eac37">tcp_check_send</a> (socket_tcp)) {</div>
<div class="line">        <span class="comment">// OK, socket is ready to send data. </span></div>
<div class="line">        sendbuf = <a class="code" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> (2);</div>
<div class="line">        sendbuf[0] = BLINKLED;</div>
<div class="line">        sendbuf[1] = p2;</div>
<div class="line">        <a class="code" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> (socket_tcp, sendbuf, SENDLEN);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga4d298c3a3ba5d9b25089e9bc026e663a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a> tcp_close </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop TCP communication and start closing procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code that indicates the execution status of the function as defined with <a class="el" href="rl__net_8h.html#a5675a3b88ee02986ae15ae3bb8135551">netStatus</a>.</dd></dl>
<p>The function <b>tcp_close</b> initiates the procedure to close the TCP connection. It might take some time to close the connection.</p>
<p>The argument <em>socket</em> specifies the socket handle.</p>
<p>The Network Core calls the listener callback function only when a remote peer has closed the connection. If the socket is closed locally by calling <b>tcp_close</b>, then the callback function is not called.</p>
<p>When a socket is of type <code>TCP_TYPE_SERVER</code> or <code>TCP_TYPE_CLIENT_SERVER</code>, the socket does not close by calling <b>tcp_close</b>. Only the active connection is closed, and the socket transits to <code>tcpStateLISTEN</code>. In this state, the socket is still able to accept incoming connections. To close the <code>TCP_TYPE_SERVER</code> socket, the function <b>tcp_close</b> needs to be called twice.</p>
<dl class="section note"><dt>Note</dt><dd>After calling <b>tcp_close</b> the socket still remains allocated until you release it.</dd></dl>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> disconnect_tcp (int32_t tcp_soc) {</div>
<div class="line">   ..</div>
<div class="line">  <span class="comment">// This TCP connection is no longer needed </span></div>
<div class="line">  <a class="code" href="group__tcp__routines.html#ga4d298c3a3ba5d9b25089e9bc026e663a">tcp_close</a> (tcp_soc);</div>
<div class="line">  <span class="comment">// Release TCP Socket in a polling function </span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> poll_socket (int32_t tcp_soc) {</div>
<div class="line">  <span class="keywordtype">int</span> state;</div>
<div class="line"> </div>
<div class="line">  state = <a class="code" href="group__tcp__routines.html#ga633f175ef72aaac9c513454f4b245ee7">tcp_get_state</a> (tcp_soc);</div>
<div class="line">  <span class="keywordflow">if</span> (state &gt; <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0baff60ac1a5d126e459570af908e62c79f">tcpStateLISTEN</a>) {</div>
<div class="line">    <span class="comment">// Closing procedure is on-going </span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (state == <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0baff60ac1a5d126e459570af908e62c79f">tcpStateLISTEN</a>) [</div>
<div class="line">    <span class="comment">// Socket has TCP_TYPE_SERVER attribute </span></div>
<div class="line">    <span class="comment">// needs additional close request.</span></div>
<div class="line">    <a class="code" href="group__tcp__routines.html#ga4d298c3a3ba5d9b25089e9bc026e663a">tcp_close</a> (tcp_soc);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// A socket is in tcpStateCLOSED state now.</span></div>
<div class="line">  <a class="code" href="group__tcp__routines.html#gacfd7657e8663ae78c0ad14084531a282">tcp_release_socket</a> (tcp_soc);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga2b350880a0604c26cefcf01c5fdfe980"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a> tcp_connect </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ip_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>local_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a TCP connection to a remote node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_addr</td><td>IP address of the remote node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>port number of the remote node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_port</td><td>local port number or 0 for system assigned local port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code that indicates the execution status of the function as defined with <a class="el" href="rl__net_8h.html#a5675a3b88ee02986ae15ae3bb8135551">netStatus</a>.</dd></dl>
<p>The function <b>tcp_connect</b> initiates a connection to a remote server. The argument <em>socket</em> is a socket handle on the local machine for communicating.</p>
<p>The argument <em>ip_addr</em> points to the buffer containing the IP address octets of the remote server.</p>
<p>The argument <em>port</em> specifies the TCP port number on the remote machine.</p>
<p>The argument <em>local_port</em> specifies the port on the local machine. If <em>local_port</em> is set to 0, then the Network Core allocates the first free TCP port automatically.</p>
<dl class="section note"><dt>Note</dt><dd>Only a socket of type <code>TCP_TYPE_CLIENT</code> or <code>TCP_TYPE_CLIENT_SERVER</code> can call the <b>tcp_connect</b> function.</dd></dl>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">int32_t tcp_soc;</div>
<div class="line"> </div>
<div class="line">uint32_t tcp_callback (int32_t soc, <a class="code" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> event, <span class="keyword">const</span> uint8_t *buf, uint32_t len) {</div>
<div class="line">  <span class="comment">// This function is called on TCP event </span></div>
<div class="line">   ..</div>
<div class="line">  <span class="keywordflow">return</span> (0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main (<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keyword">const</span> uint8_t rem_ip[4] = {192,168,1,110};</div>
<div class="line"> </div>
<div class="line">  init ();</div>
<div class="line">  <span class="comment">// Initialize the Network Core </span></div>
<div class="line">  <a class="code" href="group__net__system__functions.html#gac115122a03cf6b4b8874045f88e6ac5f">net_initialize</a> ();</div>
<div class="line">  tcp_soc = <a class="code" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> (<a class="code" href="rl__net_8h.html#a0d8130d6f21b0992437f49d907f51011">TCP_TYPE_SERVER</a>, 0, 30, tcp_callback);</div>
<div class="line">  <span class="keywordflow">if</span> (tcp_soc &gt;= 0) {</div>
<div class="line">    <span class="comment">// Start connection </span></div>
<div class="line">    <a class="code" href="group__tcp__routines.html#ga2b350880a0604c26cefcf01c5fdfe980">tcp_connect</a> (tcp_soc, rem_ip, 80, 1000);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <span class="comment">// Run main Network Core &#39;thread&#39; </span></div>
<div class="line">    <a class="code" href="group__net__system__functions.html#gaafbf279f22e31e4822d9025b9e986d22">net_main</a> ();</div>
<div class="line">     ..</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga2d0cf899981f5ceade155b43ee4de5b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * tcp_get_buf </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for TCP send buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the allocated memory.</dd></dl>
<p>The function <b>tcp_get_buf</b> allocates memory for the TCP send buffer into which your application can write the outgoing data packet. The argument <em>size</em> specifies the number of data bytes that the application wants to send.</p>
<p>After the TCP frame has been sent and an acknowledgement has been received from the remote host, the Network Core automatically de-allocates the memory used by the send buffer in the <a class="el" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> function.</p>
<p>A default Maximum Segment Size of 1460 bytes is defined at start-up. However, when establishing a connection with a remote machine, the Network Core might negotiate a different (smaller) value for the Maximum Segment Size.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Your application must call the <b>tcp_get_buf</b> function each time it wants to send a TCP data packet.</li>
<li>The size of the allocated memory must not exceed the TCP Maximum Segment Size (1460 bytes).</li>
<li>Writing more data than the allocated <em>size</em> of the data buffer overwrites the Memory Manager Block links and causes the Network Core to crash.</li>
</ul>
</dd></dl>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> send_datalog () {</div>
<div class="line">  uint8_t *sendbuf;</div>
<div class="line">  uint32_t maxlen;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__tcp__routines.html#ga28c4ed241d2df8ad14b0f12f4b3eac37">tcp_check_send</a> (tcp_soc)) {</div>
<div class="line">    <span class="comment">// The socket is ready to send the data. </span></div>
<div class="line">    maxlen = tcp_max_dsize (tcp_soc);</div>
<div class="line">    sendbuf = <a class="code" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> (maxlen);</div>
<div class="line">    memcpy (sendbuf, data_buf, maxlen);</div>
<div class="line">    <a class="code" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> (tcp_soc, sendbuf, maxlen);</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga43b571ec995be3255b7d5fa5f24634ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t tcp_get_socket </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tcp__routines.html#gace2a5afa1443e45e16fa795be3afb322">net_tcp_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a free TCP socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>socket type:<ul>
<li>TCP_TYPE_SERVER = Able to listen.</li>
<li>TCP_TYPE_CLIENT = Able to initiate a connection.</li>
<li>TCP_TYPE_DELAY_ACK = Send delayed ack.</li>
<li>TCP_TYPE_FLOW_CTRL = Control data flow.</li>
<li>TCP_TYPE_KEEP_ALIVE = Keep a connection alive. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tos</td><td>IP type of service:<ul>
<li>0 = default value. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout</td><td>idle timeout in seconds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_func</td><td>event listening callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>socket handle number or execution status:<ul>
<li>value &gt;= 0: socket handle number</li>
<li>value &lt; 0: error occurred, -value is execution status as defined with <a class="el" href="rl__net_8h.html#a5675a3b88ee02986ae15ae3bb8135551">netStatus</a></li>
</ul>
</dd></dl>
<p>The function <b>tcp_get_socket</b> allocates a free TCP socket. The function initializes all the state variables of the TCP socket to the default state. The argument <em>type</em> specifies the type of the TCP socket: </p>
<table class="doxtable">
<tr>
<th>Socket Type </th><th>Description  </th></tr>
<tr>
<td>TCP_TYPE_SERVER </td><td>The TCP socket is able to listen on the TCP port for incoming connections. </td></tr>
<tr>
<td>TCP_TYPE_CLIENT </td><td>The TCP socket is able to initiate a connection to a remote server. </td></tr>
<tr>
<td>TCP_TYPE_CLIENT_SERVER</td><td>The TCP socket is able to listen on the TCP port for incoming connections and to initiate a connection to a remote server. </td></tr>
<tr>
<td>TCP_TYPE_DELAY_ACK </td><td>This attribute improves the performance for applications sending large amounts of data like HTTP server. You can combine this attribute with the other attributes using the bitwise-or (|) operation. </td></tr>
<tr>
<td>TCP_TYPE_FLOW_CTRL </td><td>The TCP socket is able to control TCP Data Flow. You can combine this attribute with the other attributes using the bitwise-or (|) operation. </td></tr>
<tr>
<td>TCP_TYPE_KEEP_ALIVE</td><td>The TCP socket is able to send keep-alive packets when timeout expires. You can combine this attribute with the other attributes using the bitwise-or (|) operation. </td></tr>
</table>
<p>The argument <em>tos</em> specifies the IP Type Of Service. The most common value for <em>tos</em> is 0.</p>
<p>The argument <em>tout</em> specifies the idle timeout in seconds. The TCP connection is supervised by the keep alive timer. When the connection has been idle for more than <em>tout</em> seconds, the Network Core disconnects the TCP connection or sends a keep-alive packet if <code>TCP_TYPE_KEEP_ALIVE</code> attribute is set.</p>
<p>The argument <em>cb_func</em> is the event callback function of the TCP socket. The Network Core calls the function whenever a TCP event occurs. Refer to <a class="el" href="group__tcp__routines.html#gace2a5afa1443e45e16fa795be3afb322">net_tcp_cb_t</a>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>You must call the <b>tcp_get_socket</b> function before any other function calls to the TCP socket.</li>
<li>You must define the listener function to use with the TCP socket.</li>
<li>You must use the <code>TCP_TYPE_KEEP_ALIVE</code> attribute for a long-standing connection.</li>
</ul>
</dd></dl>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">int32_t tcp_soc;</div>
<div class="line"> </div>
<div class="line">uint32_t tcp_callback (int32_t soc, <a class="code" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> event, <span class="keyword">const</span> uint8_t *buf, uint32_t len) {</div>
<div class="line">  <span class="comment">// This function is called on TCP event </span></div>
<div class="line">   ..</div>
<div class="line">  <span class="keywordflow">switch</span> (event) {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a7f6c1d6db00e171f1fcaeee7e6231875">tcpEventConnect</a>:</div>
<div class="line">      <span class="comment">// Remote host is trying to connect to our TCP socket. </span></div>
<div class="line">      <span class="comment">// &#39;buf&#39; points to Remote IP, &#39;len&#39; holds the remote port. </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="comment">// Return 1 to accept connection, or 0 to reject connection </span></div>
<div class="line">      <span class="keywordflow">return</span> (1);</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a448881089a3a56cf064676fe96bb134e">tcpEventAbort</a>:</div>
<div class="line">      <span class="comment">// Connection was aborted </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a6659fcc0776e254d99ce76d7ec670704">tcpEventEstablished</a>:</div>
<div class="line">      <span class="comment">// Socket is connected to remote peer. </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7af3bc3ec2888d904f73df0cfd86818b56">tcpEventClosed</a>:</div>
<div class="line">      <span class="comment">// Connection has been closed </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7ac41a0c7a4531098a946ca62ab6ef1951">tcpEventACK</a>:</div>
<div class="line">      <span class="comment">// Our sent data has been acknowledged by remote peer </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a810f89319c9fa0cbfea81f999f948571">tcpEventData</a>:</div>
<div class="line">      <span class="comment">// TCP data frame has been received, &#39;buf&#39; points to data </span></div>
<div class="line">      <span class="comment">// Data length is &#39;len&#39; bytes </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main (<span class="keywordtype">void</span>) {</div>
<div class="line"> </div>
<div class="line">  init ();</div>
<div class="line">  <span class="comment">// Initialize the Network Core </span></div>
<div class="line">  <a class="code" href="group__net__system__functions.html#gac115122a03cf6b4b8874045f88e6ac5f">net_initialize</a> ();</div>
<div class="line">  tcp_soc = <a class="code" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> (<a class="code" href="rl__net_8h.html#a0d8130d6f21b0992437f49d907f51011">TCP_TYPE_SERVER</a>, 0, 30, tcp_callback);</div>
<div class="line">  <span class="keywordflow">if</span> (tcp_soc &gt;= 0) {</div>
<div class="line">    <span class="comment">// Start listening on TCP port 80 </span></div>
<div class="line">    <a class="code" href="group__tcp__routines.html#ga0becf4747e9fdb8d449a4d478e1a982a">tcp_listen</a> (tcp_soc, 80);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <span class="comment">// Run main Network Core &#39;thread&#39; </span></div>
<div class="line">    <a class="code" href="group__net__system__functions.html#gaafbf279f22e31e4822d9025b9e986d22">net_main</a> ();</div>
<div class="line">     ..</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga633f175ef72aaac9c513454f4b245ee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0b">tcpState</a> tcp_get_state </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine current state of a TCP socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status information as defined with <a class="el" href="group__tcp__routines.html#gadc39a1c61c0ec06bb63d8e120cd84b0b">tcpState</a>.</dd></dl>
<p>The function <b>tcp_get_state</b> determines the current state of the TCP socket. The application can monitor the progress when establishing or closing a connection with this function. The most useful state values are <code>tcpStateCLOSED</code>, <code>tcpStateLISTEN</code>, and <code>tcpStateESTABLISHED</code>.</p>
<p>The argument <em>socket</em> specifies the socket handle.</p>
<p>The <b>tcp_get_state</b> function returns the current state of the TCP socket: </p>
<table class="doxtable">
<tr>
<th>State </th><th>Description  </th></tr>
<tr>
<td><span class="XML-Token">tcpStateUNUSED</span> </td><td>Socket is free and not allocated yet. The function cannot return this value. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateCLOSED</span> </td><td>Socket is allocated to an application but the connection is closed. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateLISTEN</span> </td><td>Socket is listening for incoming connections. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateSYN_RECEIVED</span> </td><td>Socket has received a TCP packet with the flag SYN set. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateSYN_SENT</span> </td><td>Socket has sent a TCP packet with the flag SYN set. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateFIN_WAIT_1</span> </td><td>Socket has sent a FIN packet, to start the closing of the connection. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateFIN_WAIT_2</span> </td><td>Socket has received acknowledgement from the remote machine for the FIN packet it sent out from the local machine. Socket is now waiting for a FIN packet from the remote machine. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateCLOSING</span> </td><td>Socket has received a FIN packet from the remote machine independently </td></tr>
<tr>
<td><span class="XML-Token">tcpStateLAST_ACK</span> </td><td>Socket is waiting for the last ACK packet to the FIN packet it sent out. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateTIME_WAIT</span> </td><td>Socket is waiting on a 2 ms timeout before closing the connection. </td></tr>
<tr>
<td><span class="XML-Token">tcpStateESTABLISHED</span> </td><td>Socket has established a TCP connection. You can transfer data only in this state. </td></tr>
</table>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> send_data () {</div>
<div class="line">  <span class="keyword">const</span> uint8_t rem_ip[4] = {192,168,1,100};</div>
<div class="line">  uint8_t *sendbuf;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">switch</span> (<a class="code" href="group__tcp__routines.html#ga633f175ef72aaac9c513454f4b245ee7">tcp_get_state</a> (socket_tcp)) {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0ba80eea572593e77abb663121f399f755c">tcpStateUNUSED</a>:</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0baac035e480de8c9b4932aadcf701f18f7">tcpStateCLOSED</a>:</div>
<div class="line">      <span class="comment">// Connection idle, send Connect Request. </span></div>
<div class="line">      <a class="code" href="group__tcp__routines.html#ga2b350880a0604c26cefcf01c5fdfe980">tcp_connect</a> (socket_tcp, rem_ip, 1001, 0);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#gadc39a1c61c0ec06bb63d8e120cd84b0ba646b8c1597e3b2328c8bf218a624c19a">tcpStateESTABLISHED</a>:</div>
<div class="line">      <span class="comment">// We are connected, send command to remote peer. </span></div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="group__tcp__routines.html#ga28c4ed241d2df8ad14b0f12f4b3eac37">tcp_check_send</a> (socket_tcp)) {</div>
<div class="line">        <span class="comment">// OK, socket is ready to send data. </span></div>
<div class="line">        sendbuf = <a class="code" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> (2);</div>
<div class="line">        sendbuf[0] = BLINKLED;</div>
<div class="line">        sendbuf[1] = p2;</div>
<div class="line">        <a class="code" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> (socket_tcp, sendbuf, SENDLEN);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga0becf4747e9fdb8d449a4d478e1a982a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a> tcp_listen </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open TCP socket for incoming connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>local port number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code that indicates the execution status of the function as defined with <a class="el" href="rl__net_8h.html#a5675a3b88ee02986ae15ae3bb8135551">netStatus</a>.</dd></dl>
<p>The function <b>tcp_listen</b> opens a socket for incoming connections by causing the socket to listen at a local TCP port.</p>
<p>The argument <em>socket</em> specifies the socket handle to listen on the local machine.</p>
<p>The argument <em>port</em> specifies the TCP port number to listen at.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Server applications (such as Telnet and HTTP server) must open a TCP socket for listening.</li>
<li>Only sockets of type <code>TCP_TYPE_SERVER</code> or <code>TCP_TYPE_CLIENT_SERVER</code> can call the <b>tcp_listen</b> function.</li>
</ul>
</dd></dl>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">int32_t tcp_soc;</div>
<div class="line"> </div>
<div class="line">uint32_t tcp_callback (int32_t soc, <a class="code" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> event, <span class="keyword">const</span> uint8_t *buf, uint32_t len) {</div>
<div class="line">  <span class="comment">// This function is called on TCP event </span></div>
<div class="line">   ..</div>
<div class="line">  <span class="keywordflow">switch</span> (event) {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a7f6c1d6db00e171f1fcaeee7e6231875">tcpEventConnect</a>:</div>
<div class="line">      <span class="comment">// Remote host is trying to connect to our TCP socket. </span></div>
<div class="line">      <span class="comment">// &#39;buf&#39; points to Remote IP, &#39;len&#39; holds the remote port. </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="comment">// Return 1 to accept connection, or 0 to reject connection </span></div>
<div class="line">      <span class="keywordflow">return</span> (1);</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a448881089a3a56cf064676fe96bb134e">tcpEventAbort</a>:</div>
<div class="line">      <span class="comment">// Connection was aborted </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a6659fcc0776e254d99ce76d7ec670704">tcpEventEstablished</a>:</div>
<div class="line">      <span class="comment">// Socket is connected to remote peer. </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7af3bc3ec2888d904f73df0cfd86818b56">tcpEventClosed</a>:</div>
<div class="line">      <span class="comment">// Connection has been closed </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7ac41a0c7a4531098a946ca62ab6ef1951">tcpEventACK</a>:</div>
<div class="line">      <span class="comment">// Our sent data has been acknowledged by remote peer </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a810f89319c9fa0cbfea81f999f948571">tcpEventData</a>:</div>
<div class="line">      <span class="comment">// TCP data frame has been received, &#39;buf&#39; points to data </span></div>
<div class="line">      <span class="comment">// Data length is &#39;len&#39; bytes </span></div>
<div class="line">       ..</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main (<span class="keywordtype">void</span>) {</div>
<div class="line"> </div>
<div class="line">  init ();</div>
<div class="line">  <span class="comment">// Initialize the Network Core </span></div>
<div class="line">  <a class="code" href="group__net__system__functions.html#gac115122a03cf6b4b8874045f88e6ac5f">net_initialize</a> ();</div>
<div class="line">  tcp_soc = <a class="code" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> (<a class="code" href="rl__net_8h.html#a0d8130d6f21b0992437f49d907f51011">TCP_TYPE_SERVER</a>, 0, 30, tcp_callback);</div>
<div class="line">  <span class="keywordflow">if</span> (tcp_soc &gt;= 0) {</div>
<div class="line">    <span class="comment">// Start listening on TCP port 80 </span></div>
<div class="line">    <a class="code" href="group__tcp__routines.html#ga0becf4747e9fdb8d449a4d478e1a982a">tcp_listen</a> (tcp_soc, 80);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <span class="comment">// Run main Network Core &#39;thread&#39; </span></div>
<div class="line">    <a class="code" href="group__net__system__functions.html#gaafbf279f22e31e4822d9025b9e986d22">net_main</a> ();</div>
<div class="line">     ..</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaabe67549230e521404e9705e37056c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tcp_max_data_size </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine maximum number of data bytes that can be sent in TCP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum segment size in bytes.</dd></dl>
<p>The function <b>tcp_max_data_size</b> determines the maximum number of bytes that can be sent in the TCP packet (Maximum Segment Size).</p>
<p>The argument <em>socket</em> specifies the handle of the TCP socket.</p>
<p>A default Maximum Segment Size of 1460 bytes is defined at start-up. However, when establishing a connection with a remote machine, the Network Core might negotiate a different (smaller) value for the Maximum Segment Size.</p>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> send_datalog () {</div>
<div class="line">  uint8_t *sendbuf;</div>
<div class="line">  uint32_t maxlen;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__tcp__routines.html#ga28c4ed241d2df8ad14b0f12f4b3eac37">tcp_check_send</a> (tcp_soc)) {</div>
<div class="line">    <span class="comment">// The socket is ready to send the data. </span></div>
<div class="line">    maxlen = <a class="code" href="group__tcp__routines.html#gaabe67549230e521404e9705e37056c89">tcp_max_data_size</a> (tcp_soc);</div>
<div class="line">    sendbuf = <a class="code" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> (maxlen);</div>
<div class="line">    memcpy (sendbuf, data_buf, maxlen);</div>
<div class="line">    <a class="code" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> (tcp_soc, sendbuf, maxlen);</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gacfd7657e8663ae78c0ad14084531a282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a> tcp_release_socket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release TCP socket and free resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code that indicates the execution status of the function as defined with <a class="el" href="rl__net_8h.html#a5675a3b88ee02986ae15ae3bb8135551">netStatus</a>.</dd></dl>
<p>The function <b>tcp_release_socket</b> de-allocates the memory used by the TCP socket.</p>
<p>The argument <em>socket</em> specifies the handle of the socket to be released.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>You must call the <b>tcp_release_socket</b> function when you do not need the TCP socket any longer.</li>
<li>After calling <b>tcp_release_socket</b> the socket is free to use by another process.</li>
</ul>
</dd></dl>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> disconnect_tcp (int32_t tcp_soc) {</div>
<div class="line">   ..</div>
<div class="line">  <span class="comment">// This TCP connection needs to close immediately </span></div>
<div class="line">  <a class="code" href="group__tcp__routines.html#ga7b40899a11b2196853e49a7b4f442078">tcp_abort</a> (tcp_soc);</div>
<div class="line">  <span class="comment">// Socket will not be needed any more </span></div>
<div class="line">  <a class="code" href="group__tcp__routines.html#gacfd7657e8663ae78c0ad14084531a282">tcp_release_socket</a> (tcp_soc);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad79b3dfdadecaa7b11db7a12fdc51643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a> tcp_reset_window </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset TCP window size to a default value from the configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code that indicates the execution status of the function as defined with <a class="el" href="rl__net_8h.html#a5675a3b88ee02986ae15ae3bb8135551">netStatus</a>.</dd></dl>
<p>The function <b>tcp_reset_window</b> resets the TCP window size to a default value defined with <code>TCP_RECEIVE_WIN_SIZE</code> macro.</p>
<p>The argument <em>socket</em> specifies the handle of the socket for which to reset the window size.</p>
<p>This function can only be used with sockets that have a TCP flow control enabled. Enable a TCP flow control for the socket by calling the <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> function with the <code>TCP_TYPE_FLOW_CTRL</code> attribute set. This attribute enables using a Sliding Window protocol.</p>
<p>In Flow Control mode, each received data packet reduces the receiving Window Size by the number of data bytes received in the packet. Soon the window size becomes very small or 0. The remote host stops sending data and waits for a window update. As soon as the received data is processed, we can call a <b>tcp_reset_window</b> function to reopen the receiver window for further incoming data.</p>
<p>Depending on the context from where this function was called, it performs the following actions:</p>
<ul>
<li>resets the window size of the socket and returns if called from the callback function. The window size is actually changed in the acknowledge packet generated by the Network Core when the callback function returns.</li>
<li>resets the window size and sends out a Window Update packet if called from the other part of the user application.</li>
<li>does nothing if the socket is not in <code>tcpStateESTABLISHED</code> state and the <code>TCP_TYPE_FLOW_CTRL</code> attribute is not set.</li>
</ul>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">int32_t tcp_soc;</div>
<div class="line">uint8_t buf[TCP_RECEIVE_WIN_SIZE];</div>
<div class="line">uint32_t head, tail;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> send_to_uart (<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Send the data received from TCP to UART.</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (uart_busy () || head == tail) {</div>
<div class="line">    <span class="comment">// Do nothing if UART is busy or when &#39;buf&#39; is empty. </span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  send_uart (buf[tail++]);</div>
<div class="line">  <span class="keywordflow">if</span> (tail == head) {</div>
<div class="line">    <span class="comment">// The &#39;buf&#39; is empty, all bytes sent out to UART.</span></div>
<div class="line">    tail = 0;</div>
<div class="line">    head = 0;</div>
<div class="line">    <a class="code" href="group__tcp__routines.html#gad79b3dfdadecaa7b11db7a12fdc51643">tcp_reset_window</a> (tcp_soc);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uint32_t tcp_callback (int32_t soc, <a class="code" href="group__tcp__routines.html#ga02be6af8d62202579630484e0c8297c7">tcpEvent</a> event, <span class="keyword">const</span> uint8_t *buf, uint32_t len) {</div>
<div class="line">  <span class="comment">// This function is called on TCP event </span></div>
<div class="line">   ..</div>
<div class="line">  <span class="keywordflow">switch</span> (event) {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a7f6c1d6db00e171f1fcaeee7e6231875">tcpEventConnect</a>:</div>
<div class="line">      <span class="comment">// Remote host is trying to connect to our TCP socket. </span></div>
<div class="line">      <span class="comment">// &#39;buf&#39; points to Remote IP, &#39;len&#39; holds the remote port. </span></div>
<div class="line">      <span class="comment">// Return 1 to accept connection, or 0 to reject connection </span></div>
<div class="line">      <span class="keywordflow">return</span> (1);</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a448881089a3a56cf064676fe96bb134e">tcpEventAbort</a>:</div>
<div class="line">      <span class="comment">// Connection was aborted </span></div>
<div class="line">      tcp_soc = 0;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a6659fcc0776e254d99ce76d7ec670704">tcpEventEstablished</a>:</div>
<div class="line">      <span class="comment">// Socket is connected to remote peer. </span></div>
<div class="line">      tcp_soc = soc;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7af3bc3ec2888d904f73df0cfd86818b56">tcpEventClosed</a>:</div>
<div class="line">      <span class="comment">// Connection has been closed </span></div>
<div class="line">      tcp_soc = 0;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7ac41a0c7a4531098a946ca62ab6ef1951">tcpEventACK</a>:</div>
<div class="line">      <span class="comment">// Our sent data has been acknowledged by remote peer </span></div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="rl__net_8h.html#ga02be6af8d62202579630484e0c8297c7a810f89319c9fa0cbfea81f999f948571">tcpEventData</a>:</div>
<div class="line">      <span class="comment">// TCP data frame has been received, &#39;buf&#39; points to data </span></div>
<div class="line">      <span class="comment">// Data length is &#39;len&#39; bytes </span></div>
<div class="line">      memcpy (&amp;buf[head], buf, len);</div>
<div class="line">      head += par;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main (<span class="keywordtype">void</span>) {</div>
<div class="line"> </div>
<div class="line">  init ();</div>
<div class="line">  <span class="comment">// Initialize the Network Core </span></div>
<div class="line">  <a class="code" href="group__net__system__functions.html#gac115122a03cf6b4b8874045f88e6ac5f">net_initialize</a> ();</div>
<div class="line">  tcp_soc = <a class="code" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a> (<a class="code" href="rl__net_8h.html#a0d8130d6f21b0992437f49d907f51011">TCP_TYPE_SERVER</a> | <a class="code" href="rl__net_8h.html#a0fe8677b109ccd4ee1def7768a2d17aa">TCP_TYPE_FLOW_CTRL</a>,</div>
<div class="line">                            0, 30, tcp_callback);</div>
<div class="line">  <span class="keywordflow">if</span> (tcp_soc &gt;= 0) {</div>
<div class="line">    <span class="comment">// Start listening on TCP port 8080 </span></div>
<div class="line">    <a class="code" href="group__tcp__routines.html#ga0becf4747e9fdb8d449a4d478e1a982a">tcp_listen</a> (tcp_soc, 8080);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  head = 0;</div>
<div class="line">  tail = 0;</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <span class="comment">// Run main Network Core &#39;thread&#39; </span></div>
<div class="line">    <a class="code" href="group__net__system__functions.html#gaafbf279f22e31e4822d9025b9e986d22">net_main</a> ();</div>
<div class="line">    send_to_uart ();</div>
<div class="line">     ..</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae04258a1f5a0fb1d847bf00194ecc8f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__error__codes__net.html#ga5675a3b88ee02986ae15ae3bb8135551">netStatus</a> tcp_send </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a data packet to remote node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>socket handle obtained with <a class="el" href="group__tcp__routines.html#ga43b571ec995be3255b7d5fa5f24634ad">tcp_get_socket</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>buffer containing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of data in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code that indicates the execution status of the function as defined with <a class="el" href="rl__net_8h.html#a5675a3b88ee02986ae15ae3bb8135551">netStatus</a>.</dd></dl>
<p>The function <b>tcp_send</b> sends the data packet to a remote machine.</p>
<p>The argument <em>socket</em> specifies the socket handle to use for communication on the local machine.</p>
<p>The argument <em>buf</em> points to the constructed TCP data packet.</p>
<p>The argument <em>len</em> specifies the number of bytes in the data packet.</p>
<p>If the <b>tcp_send</b> fails to send the data, then it releases the memory buffer specified with the argument <em>buf</em> and returns with a status information. The function can not send data if:</p>
<ul>
<li>the TCP connection is not established</li>
<li>previously sent data is not acknowledged from the remote machine.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>You must allocate the memory using <a class="el" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> before calling <b>tcp_send</b>.</li>
<li>The buffer will be released, no matter if tcp_send is successful or not.</li>
<li>tcp_send does not send 0-length packets. It is possible to release a buffer that has been allocated, by simply calling tcp_send with parameter len = 0.</li>
<li>The socket must already be opened and connected for communication.</li>
<li>It is not allowed to call <b>tcp_send</b> from the callback function of the socket.</li>
</ul>
</dd></dl>
<p><b>Code Example</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rl__net_8h.html">rl_net.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> send_datalog () {</div>
<div class="line">  uint8_t *sendbuf;</div>
<div class="line">  uint32_t maxlen;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__tcp__routines.html#ga28c4ed241d2df8ad14b0f12f4b3eac37">tcp_check_send</a> (tcp_soc)) {</div>
<div class="line">    <span class="comment">// The socket is ready to send the data. </span></div>
<div class="line">    maxlen = <a class="code" href="group__tcp__routines.html#gaabe67549230e521404e9705e37056c89">tcp_max_data_size</a> (tcp_soc);</div>
<div class="line">    sendbuf = <a class="code" href="group__tcp__routines.html#ga2d0cf899981f5ceade155b43ee4de5b6">tcp_get_buf</a> (maxlen);</div>
<div class="line">    memcpy (sendbuf, data_buf, maxlen);</div>
<div class="line">    <a class="code" href="group__tcp__routines.html#gae04258a1f5a0fb1d847bf00194ecc8f5">tcp_send</a> (tcp_soc, sendbuf, maxlen);</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue May 25 2021 13:57:56 for Network Component by ARM Ltd. All rights reserved.
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 
	-->
	</li>
  </ul>
</div>
</body>
</html>
